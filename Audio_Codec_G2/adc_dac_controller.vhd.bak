-----------------------------------------------------------
--  Ver  :| Original Author   		:| Additional Author :| 
--  V1.0 :| Bharathwaj Muthuswamy   :| Eric Lunty        :| 
-----------------------------------------------------------
--	  Minor code tweaks + glue code added                 :|
-----------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity adc_dac_controller is port 
(
		volumeButton : in std_logic;
		volumeToggle : in std_logic;
		noteButton : in std_logic;
		noteToggle : in std_logic;
		reset : in std_logic;
		audioClock : in std_logic; -- 18.432 MHz sample clock
		bitClock : out std_logic;
		dacLRSelect : out std_logic;
		dacData : out std_logic
);
end entity;

architecture behavioral of adc_dac_controller is

	type steps_table is array (0 to 127) of integer range 0 to 6000;

	signal internalBitClock : std_logic := '0';
	signal bitClockCounter : integer range 0 to 255;
	
	signal internalLRSelect,dataCount : std_logic := '0';
	signal LRCounter : integer range 0 to 31; 
	signal leftOutCounter,rightOutCounter : integer range 0 to 15;
	
	-- DAC data registers
	signal dacDataLeftChannelRegister ,dacDataRightChannelRegister : std_logic_vector(15 downto 0);
			
	-- for waves
	signal waveCounter : integer range 0 to 47;
	signal sineWave : integer range -32768 to 32767;

	signal mult: integer range 0 to 10 := 5;	
	signal note: integer range 0 to 127 := 5;
	
	
	signal steps : steps_table :=
	(5870, 5541, 5230, 4936, 4659, 4398, 4151, 3918, 3698, 3490, 3294, 3110, 2935, 2770, 
	2615, 2468, 2329, 2199, 2075, 1959, 1849, 1745, 1647, 1555, 1467, 1385, 1307, 1234, 
	1164, 1099, 1037, 979, 924, 872, 823, 777, 733, 692, 653, 617, 582, 549, 518, 489, 
	462, 436, 411, 388, 366, 346, 326, 308, 291, 274, 259, 244, 231, 218, 205, 194, 183, 
	173, 163, 154, 145, 137, 129, 122, 115, 109, 102, 97, 91, 86, 81, 77, 72, 68, 64, 61, 
	57, 54, 51, 48, 45, 43, 40, 38, 36, 34, 32, 30, 28, 27, 25, 24, 22, 21, 20, 19, 18, 
	17, 16, 15, 14, 13, 12, 12, 11, 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 6, 5, 5, 5, 4, 4, 4, 
	4, 3);

	component waveControl is port
	(
		waveCounter : in integer range 0 to 6000;
		LUT_Factor : in integer range 0 to 6000;
		multiplier : in integer range 0 to 10;
		wave : out integer range -32768 to 32767
	);
	end component;
	
	
begin
	
	Volume: process(volumeToggle,volumeButton)
	begin	
		if rising_edge(volumeButton) then
				if volumeToggle='0' then
					if mult = 10 then
						mult <= 10;
					else
						mult <= mult + 1;
					end if;
				elsif volumeToggle='1' then
					if mult = 0 then
						mult <=0;
					else
						mult <= mult -1;
					end if;
				end if;
		end if;	
	end process;
	
	changeNote: process(noteToggle,noteButton)
	begin	
		if rising_edge(noteButton) then
				if noteToggle='1' then
					if note = 127 then
						note <= 127;
					else
						note <= note + 1;
					end if;
				elsif noteToggle='0' then
					if note = 0 then
						note <=0;
					else
						note <= note -1;
					end if;
				end if;
		end if;	
	end process;

	
	-- generate bit clock
	-- we have an 18.432 MHz reference clock (refer to audio codec datasheet, this is the required frequency)
	-- we need to shift out 16 bits, 2 channels at 48 KHz.  Hence, the count value for flipping the clock bit is
	-- count = 18.432e6/(48000*16*2) - 1 = 11 (approx)
	
	process(audioClock,reset)
	begin
		if reset = '0' then
			bitClockCounter <= 0;
			internalBitClock <= '0';
		else
			if audioClock'event and audioClock = '1' then
				if bitClockCounter < 5 then					
					internalBitClock <= '0'; 
					bitClockCounter <= bitClockCounter + 1;
				elsif bitClockCounter >= 5 and bitClockCounter < 11 then
					internalBitClock <= '1'; 
					bitClockCounter <= bitClockCounter + 1;
				else
					internalBitClock <= '0'; 
					bitClockCounter <= 0;
				end if;
			end if;
		end if;
	end process;
	bitClock <= internalBitClock;
	

	
	-- generate LeftRight select signals 
	-- flip every 16 bits, starting on NEGATIVE edge
	process(internalBitClock,reset)
	begin
		if reset = '0' then					
			dacDataLeftChannelRegister <= X"0000";
			dacDataRightChannelRegister <= X"0000";
			LRCounter <= 0;
			internalLRSelect <= '0'; -- should start at low, fig. 26 on p. 33 of audio codec datasheet
			dataCount <= '0';
			leftOutCounter <= 15;
			rightOutCounter <= 15;
		else
			if internalBitClock'event and internalBitClock = '0' then -- flip on negative edge								
				if LRCounter < 16 then	
					internalLRSelect <= '1';
					LRCounter <= LRCounter + 1;
					leftOutCounter <= leftOutCounter - 1;
					rightOutCounter <= 15;
					dataCount <= '0';					
				elsif LRCounter >= 16 and LRCounter < 32 then
					internalLRSelect <= '0';
					LRCounter <= LRCounter + 1;
					dataCount <= '0';
					leftOutCounter <= 15;
					rightOutCounter <= rightOutCounter - 1;
					if LRCounter = 31 then
						LRCounter <= 0;
						dataCount <= '1';
						dacDataLeftChannelRegister <= std_logic_vector(to_signed(sineWave,16));
						dacDataRightChannelRegister <= std_logic_vector(to_signed(sineWave,16));					
					end if;									
				end if;
			end if;
		end if;
	end process;

	dacLRSelect <= internalLRSelect;
	
	-- dac data output
	process(internalBitClock,reset,internalLRSelect)
	begin
		if reset = '0' then
			 dacData <= '0';			 
		else
			-- start on falling edge of bit clock
			if internalBitClock'event and internalBitClock = '0' then 
				if internalLRSelect = '1' then		
						dacData <= dacDataLeftChannelRegister(leftOutCounter);														
				else
						dacData <= dacDataRightChannelRegister(rightOutCounter);														
				end if;
			end if;
		end if;
	 end process;
	 
--	
	--wave address generator
	process(dataCount,reset)
	begin
		if reset = '0' then
			waveCounter <= 0;
		else
			if dataCount'event and dataCount = '1' then
				if waveCounter >= steps(note) then
					waveCounter <= 0;
				else
					waveCounter <= waveCounter + 1;
				end if;
			end if;
		end if;
	end process;
	
	--Create the sine wave at specific volumes / frequency
	wave : waveControl port map (waveCounter,4096/steps(note),mult,sineWave);	

	

	
end behavioral;
